export const markdownTest = "以下是一个使用 JavaScript 实现的较为完备的深拷贝函数，它可以处理常见的数据类型，包括对象、数组、基本数据类型、函数、正则表达式、日期对象等：\n\n```javascript\nfunction deepClone(obj) {\n    if (obj === null || typeof obj!== 'object') {\n        return obj;\n    }\n\n    if (obj instanceof Date) {\n        return new Date(obj.getTime());\n    }\n\n    if (obj instanceof RegExp) {\n        return new RegExp(obj.source, obj.flags);\n    }\n\n    if (typeof obj === 'function') {\n        return obj;\n    }\n\n    if (obj instanceof Array) {\n        return obj.map(deepClone);\n    }\n\n    if (obj instanceof Object) {\n        const result = {};\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                result[key] = deepClone(obj[key]);\n            }\n        }\n        return result;\n    }\n\n    throw new Error('Unable to clone object: ', obj);\n}\n```\n\n你可以使用以下方式测试这个函数：\n\n```javascript\n// 测试用例\nconst original = {\n    a: 1,\n    b: 'hello',\n    c: true,\n    d: null,\n    e: undefined,\n    f: [1, 2, { nested: 'value' }],\n    g: { nestedObject: { key: 'value' } },\n    h: new Date(),\n    i: new RegExp('abc', 'gi'),\n    j: function () {\n        console.log('This is a function');\n    }\n};\n\nconst cloned = deepClone(original);\n\nconsole.log(cloned);\n// 检查克隆后的对象与原对象是否为不同的实例\nconsole.log(cloned === original); \n// 检查克隆后的数组与原数组是否为不同的实例\nconsole.log(cloned.f === original.f); \n// 检查克隆后的嵌套对象与原嵌套对象是否为不同的实例\nconsole.log(cloned.g.nestedObject === original.g.nestedObject); \n// 检查克隆后的日期对象与原日期对象是否为不同的实例\nconsole.log(cloned.h === original.h); \n// 检查克隆后的正则表达式对象与原正则表达式对象是否为不同的实例\nconsole.log(cloned.i === original.i); \n// 检查克隆后的函数是否与原函数相同\nconsole.log(cloned.j === original.j); \n```\n\n### 代码说明：\n1. **基本数据类型和特殊值处理**：如果 `obj` 为 `null` 或者不是对象类型（即基本数据类型，如 `number`、`string`、`boolean`、`null`、`undefined`），直接返回 `obj`。\n2. **日期对象处理**：如果 `obj` 是 `Date` 实例，创建一个新的 `Date` 对象并返回。\n3. **正则表达式对象处理**：如果 `obj` 是 `RegExp` 实例，创建一个新的 `RegExp` 对象并返回。\n4. **函数处理**：对于函数，直接返回原函数（因为函数通常不需要深拷贝，它们在不同作用域中共享逻辑）。\n5. **数组处理**：如果 `obj` 是数组，使用 `map` 方法递归地对数组中的每个元素进行深拷贝。\n6. **普通对象处理**：如果 `obj` 是普通对象，遍历对象的属性，对每个属性值递归地进行深拷贝，并将结果存储在新对象中。\n\n这样，这个深拷贝函数能够处理多种常见的数据类型，确保在大多数情况下能够生成与原对象完全独立的副本。 "
 